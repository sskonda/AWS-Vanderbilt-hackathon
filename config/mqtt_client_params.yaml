mqtt_client:
  ros__parameters:
    broker:
      host: a2g3u8sh1ylxq-ats.iot.us-east-1.amazonaws.com             # [localhost] IP address or hostname of the machine running the MQTT broker
      port: 8883             # [1883] port the MQTT broker is listening on
      # user:              # username used for authenticating to the broker (if empty, will try to connect anonymously)
      # pass:              # password used for authenticating to the broker
      tls:
        enabled: true          # [false] whether to connect via SSL/TLS
        ca_certificate: /home/katherine/Code/aws-hackathon/AWS-Vanderbilt-hackathon/aws_iot_core/root-CA.crt   # [/etc/ssl/certs/ca-certificates.crt] CA certificate file trusted by client (relative to ROS_HOME)
    client:
      id: Nikhil-LAPTOP # unique ID string used to identify the client (broker may allow empty ID and automatically generate one)
      # buffer:
      #   size:                 # [0] maximum number of messages buffered by the bridge when not connected to broker (only available if client ID is not empty)
      #   directory:            # [buffer] directory used to buffer messages when not connected to broker (relative to ROS_HOME)
      # last_will:
      #   topic:                # topic used for this client's last-will message (no last will, if not specified)
      #   message:              # [offline] last-will message
      #   qos:                  # [0] QoS value for last-will message
      #   retained:             # [false] whether to retain last-will message
      # clean_session:        # [true] whether to use a clean session for this client
      # keep_alive_interval:  # [60.0] keep-alive interval in seconds
      # max_inflight:         # [65535] maximum number of inflight messages
      tls:
        certificate: /home/katherine/Code/aws-hackathon/AWS-Vanderbilt-hackathon/aws_iot_core/Nikhil-LAPTOP.cert.pem         #  client certificate file (only needed if broker requires client certificates; relative to ROS_HOME)
        key: /home/katherine/Code/aws-hackathon/AWS-Vanderbilt-hackathon/aws_iot_core/Nikhil-LAPTOP.public.key                 # client private key file (relative to ROS_HOME)
        # password:             # client private key password
        # version:              # TLS version (https://github.com/eclipse/paho.mqtt.cpp/blob/master/src/mqtt/ssl_options.h#L305)
        # verify:               # verify the client should conduct post-connect checks.
        # alpn_protos:          # list of ALPN protocols (https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_alpn_protos.html)
        # server_cert_auth:     # [true] whether to verify the server certificate
    bridge:
      ros2mqtt:                # Object specifying which ROS topics to map to which MQTT topics
        ros_topics:            # Array specifying which ROS topics to bridge
          - /submarines/pose # The ROS topic that should be bridged, corresponds to the sub-object in the YAML
        /submarines/pose:
          mqtt_topic: Nikhil-LAPTOP/uuv/pose          # MQTT topic on which the corresponding ROS messages are sent to the broker
          # primitive:           # [false] whether to publish as primitive message
          # ros_type:            # [*empty*] If set, the ROS msg type provided will be used. If empty, the type is automatically deduced via the publisher
          # inject_timestamp:    # [false] whether to attach a timestamp to a ROS2MQTT payload (for latency computation on receiver side)
          # advanced:
          #   ros:
          #     queue_size:      # [1] ROS subscriber queue size
          #     qos:
          #       reliability:   # [auto] One of "auto", "system_default", "reliable", "best_effort". If auto, the QoS is automatically determined via the publisher
          #       durability:    # [auto] One of "auto", "system_default", "volatile", "transient_local". If auto, the QoS is automatically determined via the publisher
          #   mqtt:
          #     qos:             # [0] MQTT QoS value
          #     retained:        # [false] whether to retain MQTT message
      # mqtt2ros:                # Object specifying which MQTT topics to map to which ROS topics
      #   mqtt_topics:           # Array specifying which ROS topics to bridge
      #     - {{ mqtt_topic_name }} # The MQTT topic that should be bridged, corresponds to the sub-object in the YAML
      #   {{ mqtt_topic_name }}:
      #     ros_topic:           # ROS topic on which corresponding MQTT messages are published
      #     ros_type:            # [*empty*] If set, the ROS msg type provided will be used. If empty, the type is automatically deduced via the MQTT message
      #     primitive:           # [false] whether to publish as primitive message (if coming from non-ROS MQTT client)
      #     advanced:
      #       mqtt:
      #         qos:             # [0] MQTT QoS value
      #       ros:
      #         queue_size:      # [1] ROS publisher queue size
      #         latched:         # [false] whether to latch ROS message
      #         qos:
      #           reliability:   # [system_default] One of "system_default", "reliable", "best_effort". 
      #           durability:    # [system_default] One of "system_default", "volatile", "transient_local". 